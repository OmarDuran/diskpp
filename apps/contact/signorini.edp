// SIGNORINI PROBLEM WITH NITSCHE
// Theta=0
// 2018 
// Test case from F. Ben Belgacem and Y. Renard., 2003.

// 1. ***************** Numerical parameters *****************

// Nitsche's parameter - Ref. value from Burman et.al = 100
real g0 = 0.1;
// Tolerance for the convergence of semi-smooth Newton
real tol=1e-10;

// 2. ***************** Mesh and FE spaces *******************
// For FE computations
int Ne = 64;
real hTAll = 1./Ne;
mesh Th=square(Ne,Ne,[x,y]);
fespace Vh(Th,P2);

// 3. ******* Functions for Newton iterations ****************

//Finite element functions for Newton solving
Vh uh,zh,duh,dzh,vh,wh;            

// Negative part
func real negative(real t)
{
	if (t<=0) return t; else return 0;
}

// Heaviside function
func real heaviside(real t)
{
	if (t>=0) return 1; else return 0;
}

// 4. ******************* Model parameters *******************

// RHS function
func f =  sin( 2* pi * x);

// 5. ************** Macros for the obstacle problem **********

// Membrane - bulk term
macro ah(u,v) ( dx(u)*dx(v) + dy(u)*dy(v) ) //EOM
// Sigma
macro sigman(u) ( dx(u)*N.x + dy(u)*N.y ) //EOM
// Nitsche's parameter
macro gnp() ( g0 / hTriangle ) //EOM
// Signorini function
macro sig(u) ( sigman(u) - gnp * u ) //EOM
macro sig_t(u, theta) ( theta * sigman(u) - gnp * u ) //EOM


// 6. ************************* SOLVING *************************

// 6.1 Initialisation of Newton -> membrane without obstacle (linear problem)

// Solve the problem
solve Membrane(uh,vh) = int2d(Th)( ah(uh,vh) ) - int2d(Th)(f*vh) 
	  - int1d(Th,1) ( (theta/gnp) * sigman(duh) * sigman(vh));
      + on(3,uh=0);

// Plot 
plot(uh,wait=true,fill=true,value=true,cmm="Initial solution",ps="Init.eps");

// Init the error (on uh)
real erru = 0; 

// 6.2  Newton loop

int iter=1;
for(iter=1;iter<100;++iter)
{

	cout << "*** Newton iteration: " << iter << ":" << endl;

   
	// Solve the tangent problem / theta
	solve Dsignorini(duh,vh) =
		  int2d(Th) ( ah(duh,vh))
		- int1d(Th,1) ( (theta/gnp) * sigman(duh) * sigman(vh))
		- int1d(Th,1) ( (1/gnp) * heaviside(-sig(uh))* sig(duh) * sig_t(vh, theta) )
		- int2d(Th) ( f*vh )
		+ int2d(Th) ( ah(uh,vh) )
		- int1d(Th,1) ( (theta/gnp) * sigman(uh) * sigman(vh))
		+ int1d(Th,1) ( (1/gnp) * negative(sig(uh))* sig_t(vh, theta) )
		+ on(3, duh = 0) ;

	// Compute the residual : relative L^2 norm of the increment on uh
	erru = sqrt ( int2d(Th) ( duh^2 ) ) / sqrt ( int2d(Th) ( uh^2) );
	cout << " * Residual : u -> " << erru << endl;

	// Stop if the residual on u is small enough
	if (erru< tol) break;

	// Update the displacement
	uh = uh+duh;
} 

// 7.**************  Post-processing ************** 
plot(uh,wait=true,fill=true,value=true,cmm="Final solution",ps="Final.eps");  

//plot(uex,wait=true,fill=true,value=true,cmm="Closed-form solution"); 

cout << " **** N elements : **** " << Ne << endl;
cout << " **** h          : **** " << hTAll << endl;
cout << " **** Newton iterations : **** " << iter  << endl;


 
